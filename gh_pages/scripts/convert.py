import markdown
from markdown.preprocessors import Preprocessor
from markdown.postprocessors import Postprocessor
from markdown.blockprocessors import BlockProcessor
from markdown.inlinepatterns import InlineProcessor
from markdown.treeprocessors import Treeprocessor
from markdown.extensions import Extension

import xml.etree.ElementTree as etree
import re
import os

html_dir = './gh_pages/pages'

mdToHtmlName = {
    'CheatSheet' : 'cheat-sheet',
    'FunctionalProgramming' : 'deduce-programming',
    'ProofIntro' : 'deduce-proofs',
    'Reference' : 'reference',
    'SyntaxGrammar' : 'syntax',
    'GettingStarted' : 'getting-started',
    'StandardLib' : 'stdlib',
    'Index' : 'index',
}

mdToTitle = {
    'CheatSheet' : 'Cheat Sheet',
    'FunctionalProgramming' : 'Programming',
    'ProofIntro' : 'Proofs',
    'Reference' : 'Reference Manual',
    'SyntaxGrammar' : 'Syntax Overview',
    'GettingStarted' : 'Getting Started',
    'StandardLib' : 'Standard Library',
    'Index' : 'Home',
}

mdToDescription = {
    'CheatSheet' : 'Cheat sheet for advice on deduce proofs.',
    'FunctionalProgramming' : 'A guide on deduce programming with exercises.',
    'ProofIntro' : 'A guide on writing proofs in deduce with exercises.',
    'Reference' : 'Full reference manual for the deduce language.',
    'SyntaxGrammar' : 'Syntax and grammar overview for the deduce language.',
    'GettingStarted' : 'Getting started with deduce.',
    'StandardLib' : 'Documentation for the deduce standard library.',
    'Index' : 'Deduce is an automated proof checker meant for use in education to help students',
}

mdToDeduceCode = {
    'CheatSheet' : 'cheat-sheet',
    'FunctionalProgramming' : 'programming',
    'ProofIntro' : 'proof',
    'Reference' : 'reference',
    'SyntaxGrammar' : 'syntax-grammar',
    'GettingStarted' : 'getting-started',
    'StandardLib' : 'stdlib',
    'Index' : 'index',
}

def safeHTMLify(s):
    return s.replace("<", "&lt;")\
            .replace(">", "&gt;")\
            .replace("\t", "    ")\
            .replace("\n", "<br>\n")\
            .replace(" ", "&nbsp;")\
            .replace("λ", "&#x03BB;")\
            .replace("≠", "&#x2260;")\
            .replace("≤", "&#x2264;")\
            .replace("≥", "&#x2265;")\
            .replace("⊆", "&#x2286;")\
            .replace("∈", "&#x2208;")\
            .replace("∪", "&#x222A;")\
            .replace("∩", "&#x2229;")\
            .replace("⨄", "&#x2A04;")\
            .replace("∘", "&#x2218;")\
            .replace("∅", "&#x2205;")

def unsafeHTMLify(s):
    return s.replace("&lt;", "<")\
            .replace("&gt;", ">")\
            .replace("&ast;", "*")\
            .replace("&amp;", "&")\
            .replace("&nbsp;", " ")\
            .replace("&#x03BB;", "λ")\
            .replace("&#x2260;", "≠")\
            .replace("&#x2264;", "≤")\
            .replace("&#x2265;", "≥")\
            .replace("&#x2286;", "⊆")\
            .replace("&#x2208;", "∈")\
            .replace("&#x222A;", "∪")\
            .replace("&#x2229;", "∩")\
            .replace("&#x2A04;", "⨄")\
            .replace("&#x2218;", "∘")\
            .replace("&#x2205;", "∅")\
            .replace("<br>\n", "\n")

class BlockPreprocessor(Preprocessor):

    def is_list(self, line):
        list_start = ['\\*', '-', '\\+', '[0-9]+\\.']
        for start in list_start:
            if re.search('^'+start, line): return True
        return False

    def run(self, lines):
        in_cb = False
        prev_line = ""

        new_lines = []

        for line in lines:
            cur_is_list = self.is_list(line)
            prev_is_list = self.is_list(prev_line)

            if '```' in line and not in_cb:
                new_lines.append("")
                in_cb = True
            elif '```' in line and '```' not in prev_line and in_cb:
                in_cb = False
            elif '```' in prev_line and not in_cb:
                new_lines.append("")

            if cur_is_list and not prev_is_list:
                new_lines.append("")
            elif prev_is_list and not cur_is_list:
                new_lines.append("")

            if in_cb and (len(line) == 0 or line.isspace()):
                # empty lines in code blocks should not indicate a new block
                line = " "
            
            prev_line = line
            new_lines.append(line)

        return new_lines

class EntangledPreprocessor(Preprocessor):

    def __init__(self, fname):
        self.fname = fname

    def run(self, lines):
        entangled_code = []

        for i in range(len(lines)):
            if re.search(r'```{\.deduce\^file=[^\.]*\.pf}', lines[i]):
                j = i + 1
                while not re.search(r'```', lines[j]):
                    entangled_code.append(lines[j])
                    j += 1

        with open(f'./test/should-validate/doc_{mdToDeduceCode[self.fname]}.pf', 'w') as f:
            f.write('// Generated by ./gh_pages/scripts/convert.py\n\n')
            for line in entangled_code:
                line = line.replace("&nbsp;", "")
                f.write(line)
                f.write("\n")

        return lines

class CodeBlockPreprocessor(Preprocessor):
    def run(self, lines):
        # otherwise it gets interpreted as a code block instead of our special code block
        # then make inequality signs safe for html then add back comments
        return [line.replace("```", "!!!")\
                    .replace("<", "&lt;")\
                    .replace(">", "&gt;")\
                    .replace("&lt;!--", "<!--")\
                    .replace("--&gt;", "-->") 
                for line in lines]

class CodeInlineProcessor(InlineProcessor):
    def handleMatch(self, m, data):
        el = etree.Element('code', {'class': 'inline'})
        el.text = m.group(1)
        return el, m.start(0), m.end(0)

class BetterAnchorPostprocessor(Postprocessor):

    def replace_anchors(self, m):
        file = m.group(1)
        link = file
        is_local_md = (file.startswith('./') and file.endswith('.md')) or len(file) == 0
        is_local_html = ((file.startswith('./') or file.startswith('../')) and file.endswith('.html')) or len(file) == 0
        is_local_lib = (file.startswith('../lib/') and (file.endswith('.pf') or file.endswith('.thm'))) or len(file) == 0
        if is_local_md and len(file) > 0:
            file = file[len('./'):-3]
            link = './' + mdToHtmlName[file] + '.html'
        if is_local_lib and len(file) > 0:
            file = file[len('../lib/'):]
            link = './stdlib/' + file + '.html'
        link_id = '' if m.group(3) is None else m.group(3)
        link_target = '_self' if is_local_md or is_local_lib or is_local_html else '_blank'
        return f'<a href="{link}#{link_id}" target="{link_target}">'

    def run(self, text):
        PATTERN = r'<a +href="([^"#]*)(#([^"]*))?">'
        return re.sub(PATTERN, self.replace_anchors, text)

class CodeBlockProcessor(BlockProcessor):
    RE_FENCE_START = r'^ *!!!({\.deduce\^?#?(.*)})? *\n' # start line, e.g., `   !!!! `
    RE_FENCE_END = r'\n *!!!\s*$'  # last non-blank line, e.g, '!!!\n  \n\n'

    def __init__(self, parser, fname, windowed):
        self.fname = fname
        self.windowed=windowed

    def test(self, parent, block):
        return re.match(self.RE_FENCE_START, block)

    def run(self, parent, blocks):
        original_block = blocks[0]

        m = re.search(r'^ *!!!{\.deduce\^#(.*)} *\n', blocks[0])
        blocks[0] = re.sub(self.RE_FENCE_START, '', blocks[0])

        for block_num, block in enumerate(blocks):
            if re.search(self.RE_FENCE_END, block):
                # remove fence
                blocks[block_num] = re.sub(self.RE_FENCE_END, '', block)
                # render fenced area inside a new div
                classes = 'code-wrapper'
                if not m: classes += ' non-deduce'
                if self.windowed: classes += ' windowed' 
                wrapper = etree.SubElement(parent, 'div', {'class' : classes})
                code = etree.SubElement(wrapper, 'code', {'id' : f'{mdToDeduceCode[self.fname]}_{m.group(1)}'} if m else {})

                code_text = []

                for i in range(0, block_num + 1):
                    code_text.append(blocks[0])
                    code_text.append("\n\n")
                    blocks.pop(0)

                code_text = code_text[:-1]
                code.text = '<!-- Generated by codeUtils.js -->' if m else safeHTMLify('\n'.join(code_text))
                if m: 
                    joined_code_text = ''.join(code_text)
                    joined_code_text = unsafeHTMLify(joined_code_text)
                    joined_code_text = joined_code_text.replace('(html_gt)', '>').replace('(html_lt)', '<')


                    with open(f'./test/should-validate/doc_{mdToDeduceCode[self.fname]}.pf', "r+") as f:
                        data = f.read()
                        f.seek(0)

                        data = data.replace(f'<<{m.group(1)}>>', joined_code_text)

                        f.write(data)
                        f.truncate()

                    with open(f"./gh_pages/deduce-code/{mdToDeduceCode[self.fname]}_{m.group(1)}.pf", "w") as f:
                        f.write('\n\n')
                        f.write(joined_code_text)

                return True  # or could have had no return statement
        # No closing marker!  Restore and do nothing
        blocks[0] = original_block
        return False  # equivalent to our test() routine returning False

class CodeBlockTreeProcessor(Treeprocessor):
    def run(self, root):
        self.fix_codeblocks(root)

    def fix_codeblocks(self, element):
        for child in element:
            # Any code blocks that weren't caught by block processor
            if child.tag == 'pre':
                child.tag = 'div'
                child.set("class", "code-wrapper non-deduce")
                code = child.find('code')
                code.text = safeHTMLify(code.text)
            # asterisks in code blocks
            if child.tag == 'div' \
                    and 'code-wrapper' in child.get('class', default='') \
                    and child.find('code') is not None:
                # otherwise it gets interpreted as an italics tag
                child.find('code').text = child.find('code').text.replace("*", "&ast;")
            else: self.fix_codeblocks(child)

class CodeExtension(Extension):
    def __init__(self, fname, windowed=False):
        self.fname = fname
        self.windowed = windowed

    def extendMarkdown(self, md):
        md.preprocessors.register(BlockPreprocessor(), 'block-pre', 10002)
        md.preprocessors.register(EntangledPreprocessor(self.fname), 'entangled', 10001)
        md.preprocessors.register(CodeBlockPreprocessor(), 'code-block-pre', 10000)
        md.inlinePatterns.register(CodeInlineProcessor(r'(?<!`)`([^`]*?)`(?!`)', md), 'code', 10000)
        md.parser.blockprocessors.register(CodeBlockProcessor(md.parser, self.fname, self.windowed), 'code-block', 10000)
        md.treeprocessors.register(CodeBlockTreeProcessor(), 'code-block-tree', 10000)
        md.postprocessors.register(BetterAnchorPostprocessor(), 'anchor', 10000)

def prelude(fname, md = True):
    relative_path = '..' if md else '.'
    classes = 'container ' +  (f'md {mdToHtmlName[fname]}' if md else '')
    return f'''
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="description" content="{mdToDescription[fname]}">
    <meta name="keywords" content="Deduce, Proof, Programming">
    <meta name="author" content="Jeremy Siek">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deduce | {mdToTitle[fname]}</title>

    <!-- Social cards -->
    <meta property="og:url" content="https://jsiek.github.io/deduce/pages/{mdToHtmlName[fname]}.html" />
    <meta property="og:type" content="website"/>
    <meta property="og:title" content="Deduce | {mdToTitle[fname]}" />
    <meta property="og:description" content="{mdToDescription[fname]}" />
    <meta property="og:site_name" content="Deduce">
    <meta property="og:image" content="https://jsiek.github.io/deduce/images/logo.svg" />
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Deduce | {mdToTitle[fname]}">
    <meta name="twitter:description" content="{mdToDescription[fname]}">
    <meta name="twitter:image" content="https://jsiek.github.io/deduce/images/logo.svg">

    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="{relative_path}/images/logo.svg">

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Josefin+Slab:ital,wght@0,100..700;1,100..700&display=swap"
        rel="stylesheet">

    <!-- Font awesome -->
    <script src="https://kit.fontawesome.com/7005573326.js" crossorigin="anonymous"></script>

    <!-- My stylesheets -->
    <link rel="stylesheet" href="{relative_path}/css/normalize.css">
    <link id="stylesheet" rel="stylesheet" href="{relative_path}/css/style.css">
</head>

<body>

    <div class="{classes}">
        <deduce-nav>
            <!-- custom component defined in script.js -->
        </deduce-nav>
    '''

def conclusion(md=True):
    relative_path = '..' if md else '.'
    return f'''
        <deduce-footer>
            <!-- custom component defined in script.js -->
        </deduce-footer>
    </div>


    <script src="{relative_path}/js/cache.js"></script>
    <script src="{relative_path}/js/script.js"></script>
    <script src="{relative_path}/js/code.js"></script>
    <script src="{relative_path}/js/codeKeywords.js" type="module"></script>
    <script src="{relative_path}/js/codeUtils.js" type="module"></script>
</body>

</html>
    '''


def convert_file(fname, generate_html):

    # read the md file
    with open(f'./gh_pages/doc/{fname}.md', 'r') as f:
        text = f.read()
        html = markdown.markdown(text, extensions=['tables', 'fenced_code', 'toc', CodeExtension(fname)])
        html = html.replace("&amp;", "&") # Post postprocessing

    # write to html file
    if generate_html:
        print("Writing html to " + f'{mdToHtmlName[fname]}.html')
        with open(os.path.join(html_dir, mdToHtmlName[fname] + '.html'), 'w') as f:
            f.write(prelude(fname))
            f.write(html)
            f.write(conclusion())

def convert_dir(dir, generate_html=True):
    if not os.path.exists(html_dir):
        os.makedirs(html_dir)

    if not os.path.exists('gh_pages/deduce-code'):
        print("Creating deduce-code folder")
        os.makedirs('gh_pages/deduce-code')

    for f in [f for f in os.listdir(dir) if os.path.isfile(os.path.join(dir, f))]:
        if f.endswith('.md'): 
            print(f'Converting {f}')
            convert_file(f[:-3], generate_html)

def update_code_js():
    with open ('./gh_pages/js/code.js', 'w') as f:
        f.write('const codeBlocks = [\n')
        for c in sorted(os.listdir('./gh_pages/deduce-code/')):
            f.write(f'\t"{c[:-3]}",\n') # remove ".pf"
        f.write(']')

if __name__ == "__main__":
    # convert all md files in the doc directory
    convert_dir("./gh_pages/doc/")
    # update code.js to reflect any new/removed code blocks
    update_code_js()
