
theorem or_not: all P:bool, Q:bool.
  if (P or Q) and not P
  then Q
proof
  arbitrary P:bool, Q:bool
  suppose prem
  cases conjunct 0 of prem
  case p {
    conclude false  by apply (conjunct 1 of prem) to p
  }
  case q {
    q
  }
end

theorem ex_mid: all b:bool. b or not b
proof
  arbitrary b:bool
  switch b {
    case true { . }
    case false { . }
  }
end

theorem or_sym: all P:bool, Q:bool.  (P or Q) = (Q or P)
proof
  arbitrary P:bool, Q:bool
  switch P {
    case true { . }
    case false { . }
  }
end

theorem and_sym: all P:bool, Q:bool.  (P and Q) = (Q and P)
proof
  arbitrary P:bool, Q:bool
  switch P {
    case true { . }
    case false { . }
  }
end

theorem eq_true: all P:bool. P ⇔ (P = true)
proof
  arbitrary P:bool
  switch P {
    case true { . }
    case false { . }
  }
end

theorem eq_false: all P:bool. not P ⇔ P = false
proof
  arbitrary P:bool
  switch P {
    case true { . }
    case false { . }
  }
end

theorem iff_equal: all P:bool, Q:bool.
  if (P ⇔ Q)  
  then P = Q
proof
  arbitrary P:bool, Q:bool
  switch P {
    case true {
      suppose q
      rewrite (apply eq_true to q)
    }
    case false {
      suppose not_q
      rewrite (apply eq_false to not_q)
    }
  }
end

theorem iff_symm: all P:bool, Q:bool.
  if (P ⇔ Q) then (Q ⇔ P)
proof
  arbitrary P:bool, Q:bool
  assume: P ⇔ Q
  have fwd: if Q then P by assume: Q apply (recall P ⇔ Q) to (recall Q)
  have bkwd: if P then Q by assume: P apply (recall P ⇔ Q) to (recall P)
  fwd, bkwd
end

theorem iff_trans: all P:bool, Q:bool, R:bool.
  if (P ⇔ Q) and (Q ⇔ R) then (P ⇔ R)
proof
  arbitrary P:bool, Q:bool, R:bool
  assume prem: (P ⇔ Q) and (Q ⇔ R)
  have fwd: if P then R by {
    assume: P
    have: Q by apply prem to recall P
    conclude R by apply prem to recall Q
  }
  have bkwd: if R then P by {
    assume: R
    have: Q by apply prem to recall R
    conclude P by apply prem to recall Q
  }
  fwd, bkwd
end

theorem contrapositive : all P : bool, Q : bool.
  if (if P then Q) and not Q then not P
proof
  arbitrary P : bool, Q : bool
  switch Q {
    case true { . }
    case false { . }
  }
end


theorem eq_sym : all T:type. all x:T, y:T.
	(x = y) = (y = x)
proof
	arbitrary T:type, x:T, y:T
	switch (x = y) {
		case true {
			have: x = y by apply eq_true to recall (x = y) = true
			replace recall x = y
		}
		case false {
			have: not (x = y) by apply eq_false to recall (x = y) = false
			switch (y = x) {
				case true {
					have: y = x by apply eq_true to recall (y = x) = true
					have: not (y = x)  by replace (recall y = x) in recall not (x = y)
					apply recall not (y = x) to recall y = x
				}
				case false { . }
			}
		}
	}
end
	
