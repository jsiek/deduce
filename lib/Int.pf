import Nat
import Base

/*

 This mechanization of integer arithmetic is adapted from the Integer
 module in the Agda standard library.

*/

union Int{
    pos(Nat)    // +10 = pos(10)
    negsuc(Nat) // -10 = negsuc(9)
}

function abs(Int) -> Nat {
  abs(pos(n)) = n
  abs(negsuc(n)) = suc(n)
}

// -------------------------------
//  Arithmetic
// -------------------------------
function operator -(Int) -> Int{
    operator -(pos(n)) = 
        switch n {
            case zero { pos(zero) }
            case suc(n') { negsuc(n') }
        }
    operator -(negsuc(n)) = pos(suc(n))
}

define operator - = λ n:Nat { - pos(n) }

define operator ⊝ = λ x:Nat, y:Nat {
    if x < y then
      -(y - x)
    else
      pos(x - y)
  }

// Addition
function operator +(Int,Int) -> Int {
    operator +(pos(n), m) =
        switch m {
            case pos(n') { pos(n + n') }
            case negsuc(n') { n ⊝ suc(n') } 
        }
    operator +(negsuc(n), m) = 
        switch m {
            case pos(n') { n' ⊝ suc(n) }
            case negsuc(n') { negsuc(suc(n + n')) }
        }
}
define operator + = λ n:Nat,m:Int { pos(n) + m }
define operator + = λ n:Int,m:Nat { n + pos(m) }

// Subtraction
define operator - = λ n:Int,m:Int { n + (- m) }
define operator - = λ n:Nat,m:Int { pos(n) - m }
define operator - = λ n:Int,m:Nat { n - pos(m) }

// Multiplication
function operator *(Int,Int) -> Int {
    operator *(pos(n), m) =
        switch m {
            case pos(n') { pos(n * n') }
            case negsuc(n') { -(n * suc(n')) }
        }
    operator *(negsuc(n), m) = 
        switch m {
            case pos(n') { -(suc(n) * n') }
            case negsuc(n') { pos(suc(n) * suc(n')) }
        }
}
define operator * = λ n:Nat,m:Int { pos(n) * m }
define operator * = λ n:Int,m:Nat { n * pos(m) }

function operator ≤(Int, Int) -> bool {
  operator ≤(pos(x), y) = 
    switch y {
      case pos(y') {     x ≤ y' }
      case negsuc(y') {  false  }
    }
  operator ≤(negsuc(x), y) = 
    switch y {
      case pos(y') {     true   }
      case negsuc(y') {  y' ≤ x }
    }
}


// Properties of absolute value and subtraction

theorem abs_neg: all n:Int. abs(- n) = abs(n)
proof
  arbitrary n:Int
  switch n {
    case pos(n') {
      switch n' {
        case 0 {
          equations
                abs(- pos(0)) 
              = 0              by definition {operator-, abs}
          ... = #abs(pos(0))#  by definition abs
       }
       case suc(n'') {
          equations
                abs(- pos(suc(n''))) 
              = suc(n'')              by definition {operator-, abs}
          ... = #abs(pos(suc(n'')))#  by definition abs
       }
     }
    }
    case negsuc(n') {
      equations
            abs(- negsuc(n'))  
          = suc(n')             by definition {operator-, abs}
      ... = #abs(negsuc(n'))#   by definition abs
    }
  }
end

// Properties of negation

theorem neg_suc: all n:Nat.
	- suc(n) = negsuc(n)
proof
  arbitrary n : Nat
  switch n {
    case 0 {
      definition {operator-, operator-}
    }
    case suc(n') {
      definition {operator-, operator-}
    }
  }
end

theorem neg_involutive: all n:Int. - - n = n
proof
  arbitrary n:Int
  switch n {
    case pos(n') {
      switch n' {
        case 0 { definition operator- }
        case suc(n'') { definition operator- }
      }
    }
    case negsuc(n') { definition operator- }
  }
end

// Properties of addition

theorem int_zero_add: all n:Int.
  0 + n = n
proof
  arbitrary n:Int
  switch n {
     case pos(n') {
       evaluate
     }
     case negsuc(n') {
       evaluate
     }
  }
end

theorem int_add_zero: all n:Int.
  n + 0 = n
proof
  arbitrary n:Int
  switch n {
     case pos(n') {
       suffices pos(n' + 0) = pos(n') by definition {operator+, operator+}
       rewrite add_zero
     }
     case negsuc(n') {
       suffices - suc(n') = negsuc(n')  
           by evaluate
       neg_suc
     }
  }
end

theorem int_add_commute: all x:Int, y:Int. x + y = y + x
proof
  arbitrary x:Int, y:Int
  suffices x + y = y + x by definition {operator+}
  switch x {
    case pos(x') {
      switch y {
        case pos(y') {
          suffices pos(x' + y') = pos(y' + x') by definition {operator+}
          rewrite add_commute[x',y']
        }
        case negsuc(y') {
          definition operator+
        }
      }
    }
    case negsuc(x') {
      switch y {
        case pos(y') {
          definition operator+
        }
        case negsuc(y') {
          suffices negsuc(suc(x' + y')) = negsuc(suc(y' + x'))
              by definition operator+
          rewrite add_commute[x', y']
        }
      }
    }
  }
end

lemma zero_subo_neg: all n:Nat. 0 ⊝ suc(n) = negsuc(n)
proof
  arbitrary n:Nat
  definition {operator⊝, operator<, operator≤, operator≤, operator-, operator-}
end

lemma int_subo_zero: all n:Nat. n ⊝ 0 = pos(n)
proof
  arbitrary n:Nat
  switch n < 0 for operator⊝ {
    case true assume n_neg {
      conclude false by definition {operator<, operator≤} in n_neg
    }
    case false assume n_pos {
      rewrite sub_zero
    }
  }
end


lemma int_subo_cancel: all n:Nat. n ⊝ n = +0
proof
  arbitrary n:Nat
  switch n < n {
    case true assume nn_true {
      conclude false by apply less_irreflexive[n] to rewrite nn_true
    }
    case false assume nn_false {
      suffices pos(n - n) = +0   by definition {operator ⊝} and rewrite nn_false
      rewrite sub_cancel
    }
  }
end

lemma suc_nat_subo: all x:Nat, y:Nat. suc(x) ⊝ suc(y) = x ⊝ y
proof
  arbitrary x:Nat, y:Nat
  switch x < y for operator ⊝{
    case true assume xy_true {
      have: x < y by rewrite xy_true
      have: suc(x) < suc(y) by apply less_suc_iff_suc_less to recall (x < y)
      definition {operator-} and rewrite apply eq_true to recall suc(x) < suc(y)
    }
    case false assume xy_false {
      have: not (suc(x) < suc(y)) by {
        assume: suc(x) < suc(y)
        have: x < y by apply less_suc_iff_suc_less to recall suc(x) < suc(y)
        rewrite xy_false in recall x < y
      }
      definition operator - and rewrite apply eq_false to recall (not (suc(x) < suc(y)))
    }
  }
end

theorem distrib_left_sub_add: all m:Nat, n:Nat, o:Nat.
  (n ⊝ o) + pos(m) = (n + m) ⊝ o
proof
  arbitrary m:Nat
  induction Nat
  case 0 {
    arbitrary o:Nat
    switch o {
      case 0 {       // n = 0, o = 0
        suffices pos(m) = pos(m - 0) by evaluate
        rewrite sub_zero
      }
      case suc(o') { // n = 0, o = suc(o')
        suffices negsuc(o') + pos(m) = m ⊝ suc(o')  by rewrite zero_subo_neg | zero_add
        definition {operator+}
      }
    }
  }
  case suc(n') assume IH {
    arbitrary o:Nat
    switch o {
      case 0 {       // n = suc(n'), o = 0
        suffices pos(suc(n') + m) = pos(suc(n' + m))
            by definition {operator+} and rewrite int_subo_zero
        definition operator+ 
      }
      case suc(o') { // n = suc(n'), o = suc(o')
        suffices (n' ⊝ o') + pos(m) = (n' + m) ⊝ o'
           by rewrite suc_add | suc_nat_subo 
        IH
      }
    }
  }
end

theorem distrib_left_sub_add_neg: all m:Nat, n:Nat, o:Nat.
  (n ⊝ o) + negsuc(m) = n ⊝ (suc(o) + m)
proof
  arbitrary m:Nat
  induction Nat
  case 0 {
    arbitrary o:Nat
    switch o {
      case 0 {       // n = 0, o = 0
        evaluate
      }
      case suc(o') { // n = 0, o = suc(o')
        suffices negsuc(o') + negsuc(m) = negsuc(suc(o' + m))
            by rewrite suc_add | zero_subo_neg | suc_add
        definition {operator+}
      }
    }
  }
  case suc(n') assume IH {
    arbitrary o:Nat
    switch o {
      case 0 {       // n = suc(n'), o = 0
        definition {operator+} and rewrite int_subo_zero | zero_add
      }
      case suc(o') { // n = suc(n'), o = suc(o')
        suffices (n' ⊝ o') + negsuc(m) = n' ⊝ (suc(o') + m)
             by rewrite suc_nat_subo | suc_add | suc_nat_subo
        IH
      }
    }
  }
end

theorem add_commute_nat_int: all x:Nat, y:Int.
  x + y = y + x
proof
  arbitrary x:Nat, y:Int
  switch y {
    case pos(y') {
      definition {operator+, operator+} and rewrite add_commute[x,y']
    }
    case negsuc(y') {
      definition {operator+, operator+}
    }
  }
end

theorem distrib_right_sub_add: all m:Nat, n:Nat, o:Nat.
  pos(m) + (n ⊝ o) = (m + n) ⊝ o
proof
  arbitrary m:Nat, n:Nat, o:Nat
  equations
        pos(m) + (n ⊝ o) 
      = (n ⊝ o) + pos(m)   by int_add_commute
  ... = (n + m) ⊝ o        by distrib_left_sub_add
  ... = (m + n) ⊝ o        by rewrite add_commute
end

theorem distrib_right_sub_add_neg: all m:Nat, n:Nat, o:Nat.
  negsuc(m) + (n ⊝ o) = n ⊝ suc(m + o)
proof
  arbitrary m:Nat, n:Nat, o:Nat
  equations
        negsuc(m) + (n ⊝ o) 
      = (n ⊝ o) + negsuc(m)         by int_add_commute
  ... = n ⊝ (suc(o) + m)            by distrib_left_sub_add_neg[m,n,o]
  ... = n ⊝ suc(m + o)              by rewrite suc_add | add_commute[o,m]
end

theorem int_add_assoc: all x:Int, y:Int, z:Int. (x + y) + z = x + (y + z)
proof
  arbitrary x:Int, y:Int, z:Int
  switch x {
    case pos(x') {
      switch y {
        case pos(y') {
          switch z {
            case pos(z') {     // x=pos(x'), y=pos(y'), z=pos(z')
              suffices pos((x' + y') + z') = pos(x' + (y' + z'))
                  by definition {operator+}
              rewrite add_assoc
            }
            case negsuc(z') { // x=pos(x'), y=pos(y'), z=negsuc(z')
              equations
                    (pos(x') + pos(y')) + negsuc(z') 
                  = (x' + y') ⊝ suc(z')                   by definition operator+
              ... = pos(x') + (y' ⊝ suc(z'))              by symmetric distrib_right_sub_add
              ... = pos(x') + #pos(y') + negsuc(z')#      by definition operator+
            }
          }
        }
        case negsuc(y') {
          switch z {
            case pos(z') {     // x=pos(x'), y=negsuc(y'), z=pos(z')
              equations
                    (pos(x') + negsuc(y')) + pos(z') 
                  = (x' ⊝ suc(y')) + pos(z')            by definition operator+
              ... = (x' + z') ⊝ suc(y')                 by distrib_left_sub_add 
              ... = pos(x') + (z' ⊝ suc(y'))            by symmetric distrib_right_sub_add
              ... = pos(x') + #(negsuc(y') + pos(z'))#  by definition operator+
            }
            case negsuc(z') { // x=pos(x'), y=negsuc(y'), z=negsuc(z')
              equations
                    (pos(x') + negsuc(y')) + negsuc(z') 
                  = (x' ⊝ suc(y')) + negsuc(z')           by definition operator+
              ... = negsuc(z') + (x' ⊝ suc(y'))           by int_add_commute
              ... = x' ⊝ suc(z' + suc(y'))                by distrib_right_sub_add_neg
              ... = x' ⊝ suc(suc(y' + z'))                by rewrite add_suc | add_commute[z',y']
              ... = #pos(x') + (negsuc(y') + negsuc(z'))# by definition operator+
            }
          }
        }
      }
    }
    case negsuc(x') {
      switch y {
        case pos(y') {
          switch z {
            case pos(z') {     // x=negsuc(x'), y=pos(y'), z=pos(z')
              equations
                    (negsuc(x') + pos(y')) + pos(z') 
                  = (y' ⊝ suc(x')) + pos(z')              by definition operator+
              ... = (y' + z') ⊝ suc(x')                   by distrib_left_sub_add
              ... = #negsuc(x') + (pos(y') + pos(z'))#    by definition operator+
            }
            case negsuc(z') { // x=negsuc(x'), y=pos(y'), z=negsuc(z')
              equations
                    (negsuc(x') + pos(y')) + negsuc(z') 
                  = (y' ⊝ suc(x')) + negsuc(z')           by definition operator+
              ... = y' ⊝ (suc(suc(x')) + z')              by distrib_left_sub_add_neg
              ... = y' ⊝ suc(suc(x' + z'))                by definition {operator+, operator+}
              ... = y' ⊝ suc(suc(z' + x'))                by rewrite add_commute
              ... = y' ⊝ #suc(suc(z')) + x'#              by definition {operator+, operator+}
              ... = (y' ⊝ suc(z')) + negsuc(x')           by symmetric distrib_left_sub_add_neg
              ... = negsuc(x') + (y' ⊝ suc(z'))           by int_add_commute
              ... = negsuc(x') + #pos(y') + negsuc(z')#   by definition operator+
            }
          }
        }
        case negsuc(y') {
          switch z {
            case pos(z') {     // x=negsuc(x'), y=negsuc(y'), z=pos(z')
              equations
                    (negsuc(x') + negsuc(y')) + pos(z') 
                  = z' ⊝ suc(suc(x' + y'))                 by definition operator+
              ... = z' ⊝ suc(suc(y' + x'))                 by rewrite add_commute
              ... = z' ⊝ #suc(suc(y')) + x'#               by definition {operator+, operator+}
              ... = (z' ⊝ suc(y')) + negsuc(x')            by symmetric distrib_left_sub_add_neg
              ... = negsuc(x') + (z' ⊝ suc(y'))            by int_add_commute
              ... = negsuc(x') + #negsuc(y') + pos(z')#    by definition operator+
            }
            case negsuc(z') { // x=negsuc(x'), y=negsuc(y'), z=negsuc(z')
              equations
                    (negsuc(x') + negsuc(y')) + negsuc(z') 
                  = negsuc(suc(suc(x' + y') + z'))             by definition operator+
              ... = negsuc(suc(suc((x' + y') + z')))           by definition operator+
              ... = negsuc(suc(suc(x' + (y' + z'))))           by rewrite add_assoc
              ... = negsuc(suc(x' + suc(y' + z')))             by rewrite symmetric add_suc[x',y'+z']
              ... = #negsuc(x') + (negsuc(y') + negsuc(z'))#   by definition operator+
            }
          }
        }
      }
    }
  }
end

// Properties of Addition and Negation

theorem int_add_inverse: all x:Int. x + -x = +0
proof
  arbitrary x:Int
  switch x {
    case pos(x') {
      switch x' {
        case 0 {
          definition {operator-, operator+, operator+}
        }
        case suc(x'') {
          suffices suc(x'') ⊝ suc(x'') = +0  by definition {operator-, operator+}
          int_subo_cancel
        }
      }
    }
    case negsuc(x') {
      suffices suc(x') ⊝ suc(x') = +0  by definition {operator-, operator+}
      int_subo_cancel
    }
  }
end

// Properties of Subtraction

theorem int_sub_cancel: all x:Int. x - x = +0
proof
  arbitrary x:Int
  suffices x + (- x) = +0 by definition operator-
  int_add_inverse
end

// Properties of Multiplication

theorem int_one_mult: all x:Int. +1 * x = x
proof
  arbitrary x:Int
  switch x {
    case pos(x') { 
      suffices pos(1 * x') = pos(x')  by definition operator*
      rewrite one_mult
    }
    case negsuc(x') {
      suffices - (1 * suc(x')) = negsuc(x')  by definition operator*
      suffices - suc(x') = negsuc(x')  by rewrite one_mult
      neg_suc
    }
  }
end

theorem int_mult_commute: all x:Int, y:Int. x * y = y * x
proof
  arbitrary x:Int, y:Int
  switch x {
    case pos(x') {
      switch y {
        case pos(y') {
          suffices pos(x' * y') = pos(y' * x')  by definition operator*
          rewrite mult_commute[x',y']
        }
        case negsuc(y') {
          suffices - (x' * suc(y')) = - (suc(y') * x')  by definition operator*
          rewrite mult_commute[x',suc(y')]
        }
      }
    }
    case negsuc(x') {
      switch y {
        case pos(y') {
          suffices - (suc(x') * y') = - (y' * suc(x'))  by definition operator*
          rewrite mult_commute[suc(x'), y']
        }
        case negsuc(y') {
          suffices pos(suc(x') * suc(y')) = pos(suc(y') * suc(x')) by definition operator*
          rewrite mult_commute[suc(x'), suc(y')]
        }
      }
    }
  }
end

// Properties of Less-Than or Equal

theorem int_less_equal_refl: all n:Int. n ≤ n
proof
  arbitrary n:Int
  switch n {
    case pos(n') {
      suffices n' ≤ n' by definition operator≤
      less_equal_refl
    }
    case negsuc(n') {
      suffices n' ≤ n' by definition operator≤
      less_equal_refl
    }
  }
end

theorem int_less_equal_trans: all m:Int, n:Int, o:Int.
  if m ≤ n and n ≤ o then m ≤ o
proof
  arbitrary m:Int, n:Int, o:Int
  switch m {
    case pos(m') {
      switch n {
        case pos(n') {
          switch o {
            case pos(o') {
              suffices (if (m' ≤ n' and n' ≤ o') then m' ≤ o') by definition operator≤
              less_equal_trans
            }
            case negsuc(o') { definition operator≤ }
          }
        }
        case negsuc(n') { definition operator≤ }
      }
    }
    case negsuc(m') {
      switch n {
        case pos(n') {
          switch o {
            case pos(o') { definition operator≤ }
            case negsuc(o') { definition operator≤ }
          }
        }
        case negsuc(n') {
          switch o {
            case pos(o') { definition operator≤ }
            case negsuc(o') {
              suffices (if (n' ≤ m' and o' ≤ n') then o' ≤ m')  by definition operator≤
              assume nm_n_on
              apply less_equal_trans[o',n',m'] to nm_n_on
            }
          }
        }
      }
    }
  }
end

theorem int_less_equal_antisymmetric:
  all x:Int, y:Int. 
  if x ≤ y and y ≤ x
  then x = y
proof
  arbitrary x:Int, y:Int
  assume xy_n_yx
  switch x {
    case pos(x') assume x_pos {
      switch y {
        case pos(y') assume y_pos {
          have: x' ≤ y' and y' ≤ x' by definition operator≤ in rewrite x_pos | y_pos in xy_n_yx
          have: x' = y' by apply less_equal_antisymmetric to (recall x' ≤ y' and y' ≤ x')
          conclude pos(x') = pos(y')  by rewrite (recall x' = y')
        }
        case negsuc(y') assume y_neg {
          conclude false by definition operator≤ in rewrite x_pos | y_neg in xy_n_yx
        }
      }
    }
    case negsuc(x') assume x_neg {
      switch y {
        case pos(y') assume y_pos {
          conclude false by definition operator≤ in rewrite x_neg | y_pos in xy_n_yx
        }
        case negsuc(y') assume y_neg {
          have: x' ≤ y' and y' ≤ x' by definition operator≤ in rewrite x_neg | y_neg in xy_n_yx
          have: x' = y' by apply less_equal_antisymmetric to (recall x' ≤ y' and y' ≤ x')
          conclude negsuc(x') = negsuc(y')  by rewrite (recall x' = y')
        }
      }
    }
  }
end
