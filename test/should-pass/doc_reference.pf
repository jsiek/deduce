// Generated by ./doc/convert.py

import Nat
import List
import Set
import MultiSet
import Maps
import Pair

assert 2 + 3 = 5
define A = m_one(5) ⨄ m_one(3) ⨄ m_one(5)
assert cnt(A)(3) = 1
assert cnt(A)(5) = 2
assert cnt(A)(7) = 0
theorem all_example_bool: all P:bool. P = true or P = false
proof
  arbitrary P:bool
  switch P {
    case true { . }
    case false { . }
  }
end
theorem all_example_intro: all x:Nat,y:Nat,z:Nat. x + y + z = z + y + x
proof
  arbitrary x:Nat, y:Nat, z:Nat
  equations
    x + y + z = (x + y) + z by symmetric add_assoc[x][y, z]
          ... = (y + x) + z by rewrite add_commute[x][y]
          ... = z + y + x by add_commute[y+x][z]
end
theorem all_example_elim: 1 + 2 + 3 = 3 + 2 + 1
proof
  all_example_intro[1, 2, 3]
end
assert true and true
assert not (true and false)
assert not (false and true)
assert not (false and false)
theorem and_example_intro: (1 = 0 + 1) and (0 = 0 + 0)
proof
  have eq1: 1 = 0 + 1 by definition operator+
  have eq2: 0 = 0 + 0 by definition operator+
  conclude (1 = 0 + 1) and (0 = 0 + 0) by eq1, eq2
end
theorem and_example_elim: all P:bool, Q:bool. if P and Q then Q and P
proof
  arbitrary P:bool, Q:bool
  assume prem: P and Q
  have p: P         by prem   // P and Q  used to prove  P
  have q: Q         by prem   // P and Q  used to prove  Q
  conclude Q and P  by p, q
end
assert [1,2] ++ [3,4] = [1,2,3,4]
theorem apply_to_example: all P:bool, Q:bool, R:bool.
  if (if P then Q) and (if Q then R) and P
  then R
proof
  arbitrary P:bool, Q:bool, R:bool
  assume prem: (if P then Q) and (if Q then R) and P
  have pq: if P then Q  by prem
  have p: P             by prem
  have q: Q             by apply pq to p
  have qr: if Q then R  by prem
  conclude R            by apply qr to q
end
theorem arbitrary_example: all x:Nat,y:Nat. if x = y then y = x
proof
  arbitrary x:Nat,y:Nat
  conclude if x = y then y = x by
    assume: x = y
    symmetric (recall x = y)
end
assert (if true then 7 else 5+6) = 7
theorem assume_example: all x:Nat,y:Nat. if (x = y) then (1 + x = 1 + y)
proof
  arbitrary x:Nat,y:Nat
  assume prem: x = y
  conclude 1 + x = 1 + y  by rewrite prem
end
define list_example = node(3, node(8, node(4, empty)))
assert length(list_example) = 3
theorem choose_example: some x:Nat. 6 = 2 * x
proof
  choose 3
  enable {operator*, operator+, operator+, operator+}
  conclude 6 = 2 * 3   by .
end
assert (suc ∘ suc)(3) = 5
theorem conclude_example: 1 + 1 = 2
proof
  conclude 1 + 1 = 2 by definition {operator+,operator+}
end
theorem conjunct_example: all P:bool, Q:bool. if P and Q then Q and P
proof
  arbitrary P:bool, Q:bool
  assume prem: P and Q
  have p: P         by conjunct 0 of prem
  have q: Q         by conjunct 1 of prem
  conclude Q and P  by p, q
end
define five = 2 + 3
define six : Nat = 1 + five
assert 5 = (define x = 3; 2 + x)
theorem define_proof_example: all x:Nat. 2 * (x + x + x) = (x + x + x) + (x + x + x)
proof
  arbitrary x:Nat
  define y = x + x + x
  suffices y + (y + 0) = y + y
    by definition {operator*,operator*,operator*}
  rewrite add_zero[y]
end
theorem length_list2: length([0,1]) = 2
proof
  suffices 1 + length([1]) = 2
      by definition length
  suffices 1 + (1 + 0) = 2
      by definition {length, length}
  definition {operator+, operator+}
end
theorem definition_in_example: all ls:List<Nat>. if length(ls) = 0 then ls = []
proof
  arbitrary ls:List<Nat>
  switch ls {
    case [] {
      .
    }
    case node(x, ls') {
      assume A: length(node(x, ls')) = 0
      have B: 1 + length(ls') = 0  by definition length in A
      have C: suc(length(ls')) = 0 by definition operator+ in B
      conclude false by C
    }
  }
end
define three = succ(succ(one))
assert 6 / three = 2
assert 7 / three = 2
assert 8 / three = 2
assert 9 / three = 3
theorem equations_example: all x:Nat, y:Nat, z:Nat.
  x + y + z = z + y + x
proof
  arbitrary x:Nat, y:Nat, z:Nat
  equations
    x + y + z = x + z + y      by replace add_commute[y]
          ... = #(x + z) + y#  by replace add_assoc
          ... = #z + x# + y    by replace add_commute
          ... = z + x + y      by replace add_assoc
          ... = z + y + x      by replace add_commute[x]
end
assert 2 > 1
assert not (1 > 1)
assert not (0 > 1)
assert 2 ≥ 1
assert 1 ≥ 1
assert not (0 ≥ 1)
assert (if true then 1 else 2) = 1
assert (if false then 1 else 2) = 2
 
theorem if_then_else_example: all P:bool.
  (if P then 1 else 2) = (if not P then 2 else 1)
proof
  arbitrary P:bool
  switch P {
    case true { . }
    case false { . }
  }
end
define S = single(1) ∪ single(2) ∪ single(3)
assert 1 ∈ S and 2 ∈ S and 3 ∈ S and not (4 ∈ S)
theorem induction_example: all n:Nat.
  n + 0 = n
proof
  induction Nat
  case 0 {
    conclude 0 + 0 = 0   by definition operator+
  }
  case suc(n') assume IH: n' + 0 = n' {
    equations
      suc(n') + 0 = suc(n' + 0)  by definition operator+
              ... = suc(n')      by replace IH
  }
end
define empty_nat_list = @empty<Nat>
define C = single(1) ∪ single(2)
define D = single(2) ∪ single(3)
assert 2 ∈ C ∩ D
assert not (1 ∈ C ∩ D)
assert not (3 ∈ C ∩ D)
assert 1 < 2
assert not (1 < 1)
assert not (2 < 1)
assert 1 ≤ 1
assert 1 ≤ 2
assert not (2 ≤ 1)
theorem mark_example: all x:Nat. if x = 1 then x + x + x = 3
proof
  arbitrary x:Nat
  assume: x = 1
  equations
    #x# + x + x = 1 + x + x   by replace recall x = 1
  $ 1 + #x# + x = 1 + 1 + x   by replace recall x = 1
  $ 1 + 1 + #x# = 1 + 1 + 1   by replace recall x = 1
            ... = 1 + #x# + 1 by replace recall x = 1
            ... = 1 + 1 + 1   by replace recall x = 1
            ... = 3           by definition {operator+,operator+}
end
define two = succ(one)
assert 1 % two = 1
assert 2 % two = 0
assert 3 % two = 1
assert 4 % two = 0
theorem obtain_example: all n:Nat. 
  if (some x:Nat. n = 4 * x) then (some x:Nat. n = 2 * x)
proof
  arbitrary n:Nat
  assume prem: (some x:Nat. n = 4 * x)
  obtain x where m4: n = 4 * x from prem
  choose 2 * x
  equations
     n = 4 * x          by m4
   ... = (2 * 2) * x    by evaluate
   ... = 2 * 2 * x      by mult_assoc
end
assert true or true
assert true or false
assert false or true
assert not (false or false)
theorem or_example_intro1: all P:bool, Q:bool. if P then P or Q
proof
  arbitrary P:bool, Q:bool
  assume: P
  conclude P or Q by recall P
end
theorem or_example_intro2: all P:bool, Q:bool. if Q then P or Q
proof
  arbitrary P:bool, Q:bool
  assume: Q
  conclude P or Q by recall Q
end
print five
theorem rewrite_example: all x:Nat,y:Nat. if (x = y) then (1 + x = 1 + y)
proof
  arbitrary x:Nat,y:Nat
  assume prem: x = y
  suffices 1 + y = 1 + y by rewrite prem
  .
end
theorem rewrite_in_example: all x:Nat, y:Nat.
  if x < y then not (x = y)
proof
  arbitrary x:Nat, y:Nat
  assume: x < y
  assume: x = y
  have: y < y by rewrite (recall x = y) in (recall x < y)
  conclude false by apply less_irreflexive[y] to (recall y < y)
end
define flip = fun x:bool {
  switch x {
    case true { false }
    case false { true }
  }
}
assert flip(false)
assert not flip(true)
theorem switch_proof_example: all x:Nat. x = 0 or 0 < x
proof
  arbitrary x:Nat
  switch x {
    case 0 assume xz: x = 0 {
      conclude true or 0 < 0 by .
    }
    case suc(x') assume xs: x = suc(x') {
      have z_l_sx: 0 < suc(x')
          by definition {operator <, operator ≤, operator ≤}
      conclude suc(x') = 0 or 0 < suc(x') by z_l_sx
    }
  }
end
define E = single(1)
define F = single(1) ∪ single(2)
 
theorem subset_example: E ⊆ F
proof
  suffices all x:Nat. if x ∈ E then x ∈ F  by definition operator ⊆
  arbitrary x:Nat
  assume: x ∈ E
  have: 1 = x       by definition {E, operator∈, single, rep} in recall (x ∈ E)
  suffices 1 ∈ F    by rewrite symmetric (recall 1 = x)
  definition {F, operator∈, single, operator ∪, rep}
end
theorem suffices_example:
  length(node(3, empty)) = 1
proof
  suffices 1 + 0 = 1  by definition {length, length}
  add_zero
end
theorem true_example: true
proof
  .
end
union Tree {
  Leaf(Nat)
  Internal(Tree, Nat, Tree)
}
 
/*
            5
           / \
          4   7

*/

define T1 : Tree = Leaf(4)
define T2 : Tree = Leaf(7)
define T3 : Tree = Internal(T1, 5, T2)
fun exchange(p : Pair<Nat,Nat>) {
  pair(second(p), first(p))
}
 
assert exchange(pair(1,2)) = pair(2,1)
union NatList {
  Empty
  Node(Nat, NatList)
}
 
recursive length(NatList) -> Nat {
  length(Empty) = 0
  length(Node(n, next)) = 1 + length(next)
}
define swap = fun<T, U> p:Pair<T,U> { pair(second(p), first(p)) }
 
assert first(swap(pair(1,2))) = 2
assert second(swap(pair(1,2))) = 1
